# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GLIhB7Li1fJGw_F98qAyX-cBevoBm8VH
"""

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
tf.logging.set_verbosity(tf.logging.ERROR)

import numpy as np
import os
import matplotlib.pyplot as plt
import cv2
from skimage.transform import resize

# %matplotlib inline

from os.path import isdir
import operator
from os import listdir
from imutils.video import VideoStream
import imutils
from time import time, sleep
writer = None
sleep(2.0)

import keras
from keras import models
from keras.models import Sequential
from keras.layers import Dense, Conv2D, MaxPool2D , Flatten, Input, Dense
from keras.callbacks import EarlyStopping, ModelCheckpoint
from keras.engine import  Model

from PIL import Image
from numpy import asarray, expand_dims, dot
from numpy.linalg import norm
import math
from math import floor

# loading the facenet model
model = models.load_model('../prebuilt_models/facenet_keras.h5')

faceCascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

from sklearn.model_selection import train_test_split
import pandas as pd
from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder, Normalizer
from sklearn.metrics import accuracy_score
from sklearn.manifold import TSNE
from sklearn.svm import SVC

try:
    if not os.path.exists('../input/frames_path'):
        os.makedirs('../input/frames_path')
except OSError as e:
    if e.errno != errno.EEXIST:
        raise

base_path = '../'
frame_path = '../input/frames_path/'

if len(os.listdir('../input/frames_path')) == 0:
    count = 0
    file = "Friends - Monica and Chandler's Wedding, Part 1 _ 5.mp4"
    video_object = cv2.VideoCapture(file)
    rate_of_frame = video_object.get(5)

    while(video_object.isOpened()):
        frame_id = video_object.get(1)
        content, frame = video_object.read()
        if (content != True):
            break
        if (frame_id % floor(rate_of_frame) == 0):
            filename ="frame%d.jpg" % count;count+=1
            cv2.imwrite(base_path+frame_path+filename, frame)
    video_object.release()
    print ("Done!")

else:
    print("Directory is not empty")

def face_extract_using_CV(path):

    image = cv2.imread(path)
    color = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    faces = faceCascade.detectMultiScale(
    color,
    scaleFactor=1.2,
    minNeighbors=10,
    minSize=(64,64),
    flags=cv2.CASCADE_SCALE_IMAGE
    )

    return image, faces

def resize_face(filename, size):

    image = cv2.imread(filename)
    resize_image = resize(image, size)
    pixels = asarray(resize_image)
    return pixels

def faces_from_folders(folder, size):

    extracted_faces = []

    for filename in listdir(folder):
        image_path = folder + filename
        face = resize_face(image_path, size)
        extracted_faces.append(face)

    return extracted_faces

def loading_images(folder, size):
    X = [] ; y = []

    for sub_folder in listdir(folder):

        image_path = folder + sub_folder + '/'
        faces = faces_from_folders(image_path, size)
        labels = [sub_folder for _ in range(len(faces))]

        print('Loaded %d samples for character: %s' % (len(faces), sub_folder))

        X.extend(faces)
        y.extend(labels)

    return asarray(X), asarray(y)

# load train dataset
X_train, y_train = loading_images("../input/train/", (160,160))
print(X_train.shape, y_train.shape)

# load test dataset
X_test, y_test = loading_images("../input/val/", (160,160))
print(X_test.shape, y_test.shape)

def embedding_generation_from_facenet(model, pixels):

    pixels            = pixels.astype('float32')
    pixels_mean       = np.mean(pixels)
    pixels_deviation  = np.std(pixels)
    normalized_pixels = (pixels - pixels_mean) / pixels_deviation
    transformed_pixel = expand_dims(normalized_pixels, axis=0)
    embeddings = model.predict(transformed_pixel)

    return embeddings[0]

def embedded_array(array_data):

    embedding_list = []
    for face_pixels in array_data:
        embedding = embedding_generation_from_facenet(model, face_pixels)
        embedding_list.append(embedding)
    embedding_list = asarray(embedding_list)
    print(embedding_list.shape)

    return embedding_list

X_train_embedded = embedded_array(X_train)

X_test_embedded = embedded_array(X_test)

l2_encoder = Normalizer(norm='l2')

def vectorize_vectors(encoder, dataX):

    normalized_data = []
    for data_x in dataX:
        normalized_data.append(encoder.transform(data_x))

    return normalized_data

vectorized_data = vectorize_vectors(l2_encoder, [X_train_embedded, X_test_embedded])
normalized_train = vectorized_data[0]
normalized_test  = vectorized_data[1]

print(normalized_train.shape, normalized_test.shape)

def encode_target(datay1, datay2):

    label_encoder = LabelEncoder()
    label_encoder.fit(datay1)
    datay1_train  = label_encoder.transform(datay1)
    datay2_test   = label_encoder.transform(datay2)

    return label_encoder, datay1_train, datay2_test

label_encoder, encoded_train, encoded_test = encode_target(y_train, y_test)

# fit model
ml_model = SVC(kernel='linear', probability=True)
ml_model.fit(normalized_train, encoded_train)

predictions_train = ml_model.predict(normalized_train)
predictions_test  = ml_model.predict(normalized_test)

print('accuracy score : ', accuracy_score(predictions_test, encoded_test))

targets = label_encoder.inverse_transform(encoded_train)

train_embedded = TSNE(n_components=2).fit_transform(normalized_train)

for i, t in enumerate(set(targets)):
    idx = targets == t
    plt.scatter(train_embedded[idx, 0], train_embedded[idx, 1], label=t)

plt.legend(bbox_to_anchor=(1, 1));

label_map = {}
for index,name in enumerate(label_encoder.classes_):
    label_map[index] = name

label_map

def plot(img):
    plt.figure(figsize=(8,4))
    plt.imshow(img[:,:,::-1])
    plt.show()

folder = '../input/test_frames/'
size = (160,160)

for filename in listdir(folder):
    # path
    frame_path = folder + filename
    image, faces = face_extract_using_CV(frame_path)
    for (x, y, w, h) in faces:
        cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)
        roi_color = image[y:y + h, x:x + w]
        res_img   = resize(roi_color,size)
        pixels    = asarray(res_img)
        embed     = embedding_generation_from_facenet(model, pixels)
        norm_vec  = l2_encoder.transform(np.expand_dims(embed,axis=0))
        per_prob  = ml_model.predict_proba(norm_vec)[0]
        cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)
        if np.max(per_prob) >=0.5:
            name=label_map[np.argmax(per_prob)]
            img=cv2.putText(image,name,(x,y-10),cv2.FONT_HERSHEY_SIMPLEX,2,(255,0,255),2,cv2.LINE_AA)
        else:
            img=cv2.putText(image,'others',(x,y-10),cv2.FONT_HERSHEY_SIMPLEX,2,(255,0,255),2,cv2.LINE_AA)

    cv2.imwrite(folder+frame_path.split('/')[-1].split('.')[0]+'_facenet_pred.jpg',image)
    plot(image)